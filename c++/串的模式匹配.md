## 串的模式匹配 ##

1. 朴素算法

```c++
#include<iostream>
#include<string>
using namespace std;
void simple(string a,string b){
	for(int i=0;i<a.size();++i){
		for(int j=0;j<=b.size();++j){
			if(j==b.size()){
				cout<<"posi: "<<i<<endl;
				break;
			}
			if(a[i+j]==b[j]){
				continue;
			}
			else{
				break;
			}
		}
	}
	return;
}
int main(){
	string a,b;
	cin>>a>>b;
	simple(a,b);
	return 0;
}
```

时间复杂度极高,为![](http://latex.codecogs.com/gif.latex?O(n*m))

2. KMP

假定`a`为文本串,`b`为模板串.

设
```
a = abaabababb
b = ababa
```

|下标|0|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|---|---|
|文本串|**a**|**b**|**a**|a|b|a|b|a|b|b|
|模板串|**a**|**b**|**a**|b|a|

显然,此时模板串与文本串的前3个元素相同,但第四个元素不同

如果使用朴素算法,则b要后移一位,但是从表格中可以看出,后移一位是必然不能完成匹配的

kmp算法的精妙之处在于,在完成一次尝试后,根据已知条件来向后移动尽可能远的距离

在这个例子中,第一次尝试发现在第一个不匹配项之前,一共有3项成功匹配

在这三项中,a一共出现了两次,在匹配成功的模板子串`aba`中,第三个的`a`可以视为前两个元素`ab`所构成的串的子串,`a`与`ab`匹配

将模板子串`aba`拓展为模板串`ababa`,可以得到一系列子串(包含模板串自身)

在这些子串中,存在**前n个字符**与**后n个字符**相同的情况,称其为部分匹配.记录使得**前n个字符**恰等于**后n个字符**的**最大**的n

P.S. 由于自己与自己必然匹配,所以不考虑自匹配的n

|a|b|a|||
|---|---|---|---|---|
|||a|b|a||

`n=1`

|a|b|a|b||||
|---|---|---|---|---|---|---|
|||a|b|a|b||||

`n=2`

|a|b|a|b|a||||
|---|---|---|---|---|---|---|---|
|||a|b|a|b|a|||||

`n=3`

|子串|n|匹配出的子串|
|---|---|---|
|a|0|无|
|ab|0|无|
|aba|1|a|
|abab|2|ab|
|ababa|3|aba|

将这些n写入数组中,可以得到一个**部分匹配**数组,设该数组为f

|下标|0|1|2|3|4|
|---|---|---|---|---|---|
|模板串|a|b|a|b|a|
|部分匹配f|0|0|1|2|3|

既然前三个字符成功匹配,说明模板串的前三个字符与文本串开始匹配处的前三个字符相同,同时,成功匹配的子串`aba`,存在部分匹配

那么,模板串的第一个字符和文本串开始匹配处的第三个字符是一样的

说明在开始匹配时,可以将模板串的第一个字符和文本串开始匹配处的第三个字符处对应,即将模板串向后移动两个字符的位置

从已知信息来看,是有可能完成匹配的

现在要实现kmp算法剩下的问题有两个

1. 如何得到部分匹配数组
2. 如何求出模板串向后移动的距离

1.部分匹配数组,可以看作是自身对自身的多次匹配

|a|b|a|b|a|||
|---|---|---|---|---|---|---|
|a|b|a|b|a|||

初始值为0,f[0]=0,f[1]=0

f数组除了记录当前的最大匹配n之外,也是作为字符串的索引值

要完成匹配,则说明当前检测的字符要与模板串**在索引值的位置所对应的字符**相同

例如,此时要进行检测模板串(string)中的第一个元素与第**零**个元素是否匹配

|a|b|a|b|a|||
|---|---|---|---|---|---|---|
||a|b|a|b|a||
||↑||||||

string[1]='b',f[1]=0,f作为索引,说明要完成匹配,即string[1]要与string[f[1]]相同

string[f[1]]即为string[0]即为a,无法匹配,那么将f[2]设置为0

说明此时检测的任务转变为了模板串中的第二个元素与第零个元素是否匹配,将模板串向后移动

|a|b|a|b|a|||
|---|---|---|---|---|---|---|
|||a|b|a|b|a|
|||↑|||||

string[2]='a',f[2]=0,f作为索引,string[f[2]]=='a'==string[2]

说明此时模板串中的第二个元素与第零个元素成功匹配,如果要让这个成功匹配延续下去

那么将f[3]设置为1,说明此时检测的任务转变为了模板串中的第三个元素与第一个元素是否匹配

模板串不进行移动,比较指针向后移动

|a|b|a|b|a|||
|---|---|---|---|---|---|---|
|||a|b|a|b|a|
||||↑||||

string[3]='b',f[3]=1,f作为索引,string[f[3]]=='b'==string[3]

说明此时模板串中的第三个元素与第一个元素成功匹配,如果要让这个成功匹配延续下去

那么将f[4]设置为2,说明此时检测的任务转变为了模板串中的第四个元素与第二个元素是否匹配

模板串不进行移动,比较指针向后移动

|a|b|a|b|a|||
|---|---|---|---|---|---|---|
|||a|b|a|b|a|
|||||↑|||

string[4]='a',f[4]=2,f作为索引,string[f[4]]=='b'==string[4]

说明此时模板串中的第四个元素与第二个元素成功匹配,如果要让这个成功匹配延续下去

那么将f[5]设置为3,说明此时检测的任务转变为了模板串中的第五个元素与第三个元素是否匹配

但是此时比较指针已经到达字符串的末尾,所以停止匹配

## 串的模式匹配 ##

1. 朴素算法

```c++
#include<iostream>
#include<string>
using namespace std;
void simple(string a,string b){
	for(int i=0;i<a.size();++i){
		for(int j=0;j<=b.size();++j){
			if(j==b.size()){
				cout<<"posi: "<<i<<endl;
				break;
			}
			if(a[i+j]==b[j]){
				continue;
			}
			else{
				break;
			}
		}
	}
	return;
}
int main(){
	string a,b;
	cin>>a>>b;
	simple(a,b);
	return 0;
}
```

时间复杂度极高,为![](http://latex.codecogs.com/gif.latex?O(n*m))

2. KMP

假定`a`为文本串,`b`为模板串.

设
```
a = abaabababb
b = ababa
```

|下标|0|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|---|---|
|文本串|***a***|***b***|***a***|a|b|a|b|a|b|b|
|模板串|***a***|***b***|***a***|b|a|

显然,此时模板串与文本串的前3个元素相同,但第四个元素不同

如果使用朴素算法,则b要后移一位,但是从表格中可以看出,后移一位是必然不能完成匹配的

kmp算法的精妙之处在于,在完成一次尝试后,根据已知条件来向后移动尽可能远的距离

在这个例子中,第一次尝试发现在第一个不匹配项之前,一共有3项成功匹配

在这三项中,a一共出现了两次,在匹配成功的模板子串`aba`中,第三个的`a`可以视为前两个元素`ab`所构成的串的子串,`a`与`ab`匹配

将模板子串`aba`拓展为模板串`ababa`,可以得到一系列子串(包含模板串自身)

在这些子串中,存在***前n个字符***与***后n个字符***相同的情况,称其为部分匹配.记录使得***前n个字符***恰等于***后n个字符***的***最大***的n

P.S. 由于自己与自己必然匹配,所以不考虑自匹配的n

|子串|n|匹配出的子串|
|---|---|---|
|a|0|无|
|ab|0|无|
|aba|1|a|
|abab|2|ab|
|ababa|3|aba|

将这些n写入数组中,可以得到一个***部分匹配***数组

|下标|0|1|2|3|4|
|---|---|---|---|---|---|
|模板串|a|b|a|b|a|
|部分匹配|0|0|1|2|3|

既然前三个字符成功匹配,说明模板串的前三个字符与文本串开始匹配处的前三个字符相同,同时,成功匹配的子串`aba`,存在部分匹配

那么,模板串的第一个字符和文本串开始匹配处的第三个字符是一样的

说明在开始匹配时,可以将模板串的第一个字符和文本串开始匹配处的第三个字符处对应,即将模板串向后移动两个字符的位置

从已知信息来看,是有可能完成匹配的

现在要实现kmp算法剩下的问题有两个

1. 如何得到部分匹配数组
2. 如何求出模板串向后移动的距离


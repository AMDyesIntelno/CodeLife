***Sample***

`46+5*(120-37)`

***Out***
```
46 5 120 37 - * + 
461
```


```c++
//中缀表达式转逆波兰式
#include<iostream>
#include<string>
#include<stack>
using namespace std;
int fir(char c){//比较加减和乘除优先级
    if(c=='+'||c=='-'){
        return 0;
    }
    else{
        return 1;
    }
}
int main(){
    string str;
    cin>>str;
    stack <char>s1;//临时符号栈
    stack <string>s2;//处理栈
    stack <string>rpn;//rpn栈
    stack <int>num;//运算结果栈
    string temp;
    for(int i=0;i<str.size();++i){
        if(str[i]<='9'&&str[i]>='0'){//数字处理
            temp+=str[i];
        }
        else if(str[i]=='('){//当遇到左括号时，将数字压入处理栈中，将左括号压入临时符号栈中
            s1.push(str[i]);
            s2.push(temp);
            temp.erase();
        }
        else if(str[i]==')'){//当遇到右括号时，将数字压入处理栈中，此时，右括号不必压入临时符号栈
            s2.push(temp);
            temp.erase();
            while(s1.top()!='('){//此时，弹出临时符号栈中的符号并压入处理栈中，此处为处理一对括号中包含的运算
                temp+=s1.top();
                s2.push(temp);
                s1.pop();
                temp.erase();
            }
            s1.pop();//将左括号丢弃
        }
        else{//当遇到运算符时，将数字压入处理栈中
            s2.push(temp);
            temp.erase();
            if(s1.empty()){//当临时符号栈为空时，直接将当前运算符压入栈中
                s1.push(str[i]);
            }
            else{//将当前运算符与临时符号栈的栈顶运算符进行比较
                if(fir(str[i])>fir(s1.top())){//当前运算符的优先级高于(不包括等于)临时符号栈的栈顶运算符，继续压入临时符号栈中
                    s1.push(str[i]);
                }
                else{
                    while(!s1.empty()&&s1.top()!='('&&fir(s1.top())>=fir(str[i])){
                        /*弹出临时符号栈的栈顶元素，将其转换为string类型并压入处理栈中直到
                        1.临时符号栈为空
                        2.临时符号栈的栈顶元素为左括号
                        3.临时符号栈的栈顶元素的优先级低于(不包括等于)当前运算符的优先级*/
                        temp+=s1.top();
                        s1.pop();
                        s2.push(temp);
                        temp.erase();
                    }
                    s1.push(str[i]);//将当前运算符压入临时符号栈
                }
            }
        }
    }
    s2.push(temp);//将最后一个数压入处理栈中
    temp.erase();
    while(!s1.empty()){//将剩余的运算符压入处理栈中
        temp+=s1.top();
        s1.pop();
        s2.push(temp);
        temp.erase();
    }
    str.erase();
    int t=0,num1=0,num2=0;
    while(!s2.empty()){//将处理栈逆序
        rpn.push(s2.top());
        s2.pop();
    }
    while(!rpn.empty()){//将rpn栈链接成逆波兰式，并利用rpn栈进行运算
        if(rpn.top()=="+"){
            num1=num.top();
            num.pop();
            num2=num.top();
            num.pop();
            num.push(num2+num1);
        }
        else if(rpn.top()=="-"){
            num1=num.top();
            num.pop();
            num2=num.top();
            num.pop();
            num.push(num2-num1);//注意是num2-num1
        }
        else if(rpn.top()=="*"){
            num1=num.top();
            num.pop();
            num2=num.top();
            num.pop();
            num.push(num2*num1);
        }
        else if(rpn.top()=="/"){
            num1=num.top();
            num.pop();
            num2=num.top();
            num.pop();
            num.push(num2/num1);//注意是num2/num1
        }
        else if(rpn.top().size()){//可能有空的栈单元
            for(int i=0;i<rpn.top().size();++i){
                t*=10;
                t+=rpn.top()[i]-'0';
            }
            num.push(t);
            t=0;
        }
        str+=rpn.top();
        if(rpn.top().size()){
            str+=" ";
        }
        rpn.pop();
    }
    cout<<str<<endl<<num.top();
    return 0;
}
```
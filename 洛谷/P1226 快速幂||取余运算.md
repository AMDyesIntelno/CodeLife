## 快速幂 ##
### 递归法 ###
a^b 假设b为奇数，则 a^ b可转化为 a^(b/2)* a^(b/2)*a

假设b为偶数，则 a^ b 可转化为 a^(b/2)* a^(b/2)

以此类推，可以得到递归
```c++
#include<iostream>
using namespace std;
long long fun(long long a,long long b){
    if(b==0){
        return 1;
    }
    long long base=fun(a,b/2);
    if(b%2){
        return base*base*a;
    }
    else{
        return base*base;
    }
}
int main(){
    long long a,b;
    cin>>a>>b;
    cout<<fun(a,b);
    return 0;
}
```
### 非递归法 ###
假设 ans = 1 (保证在零次幂时可用)

a^b 假设 b 转化为二进制是 101 那么 a^b 可以转化为 a^4 * a^1 

当 b 的二进制的末位是 1 时，将当前二进制位为 1 所对应的幂乘到 ans 中

无论此时b 的二进制的末位是否为 1 ，都将 a 平方以对应 b 的下一个二进制位，并将 b 的二进制右移 1 位以更新 b 的二进制末位

```c++
#include<iostream>
using namespace std;
long long fun(long long a,long long b){
    long long ans=1;
    while(b>0){
        if(b&1){
            ans*=a;
        }
        a*=a;
        b>>=1;
    }
    return ans;
}
int main(){
    long long a,b;
    cin>>a>>b;
    cout<<fun(a,b);
    return 0;
}
```

## 取余 ##

(a * b) % c = (a % c * b % c) % c 

(a^b) % c = ((a % c)^b) % c 

所以题解如下
```c++
#include<iostream>
using namespace std;
long long fun(long long a,long long b,long long c){
    if(b==0){
        return 1;
    }
    long long base=fun(a,b/2,c);
    if(b%2){
        return base*base*a%c;
    }
    else{
        return base*base%c;
    }
}
int main(){
    long long a,b,c;
    cin>>a>>b>>c;
    cout<<a<<"^"<<b<<" mod "<<c<<"="<<fun(a,b,c)%c;
    return 0;
}
```

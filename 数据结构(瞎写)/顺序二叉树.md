```c++
#include<iostream>
#include<cmath>
#include<ctime>
#define MAX_SIZE 100
using namespace std;
void Init_tree(char *t){//初始化
    for(int i=0;i<MAX_SIZE;++i){
        t[i]=0;
    }
    return;
}
void Clear_tree(char *t){//清空树
    for(int i=0;i<MAX_SIZE;++i){
        t[i]=0;
    }
    return;
}
void Create_tree(char *t){//创建树,以空格代表空结点
    char temp;
    int i=0;
    temp=getchar();
    while(temp!='\n'){
        if(temp==' '){
            t[i++]='\0';
        }
        else{
            t[i++]=temp;
        }
        temp=getchar();
    }
}
bool IsEmpty_tree(char *t){//检查树是否为空
    return t[0]==0?1:0;
}
int Length_tree(char *t){//树的长度
    int l=MAX_SIZE-1;
    for(l;l>=0;--l){
        if(t[l]!='\0'){
            break;
        }
    }
    return l;
}
int Depth_tree(char *t){//树的深度
    int d=1;
    while((pow(2,d)-1)<Length_tree(t)){
        ++d;
    }
    return d;
}
void Preorder_traversal(char *t,int posi){//先序遍历
    if(t[posi]){
        cout<<t[posi];
        Preorder_traversal(t,2*posi+1);
        Preorder_traversal(t,2*(posi+1));
    }
    return;
}
void Inorder_traversal(char *t,int posi){//中序遍历
    if(t[posi]){
        Inorder_traversal(t,2*posi+1);
        cout<<t[posi];
        Inorder_traversal(t,2*(posi+1));
    }
    return;
}
void Postorder_traversal(char *t,int posi){//后序遍历
    if(t[posi]){
        Postorder_traversal(t,2*posi+1);
        Postorder_traversal(t,2*(posi+1));
        cout<<t[posi];
    }
    return;
}
void Levelorder_traversal(char *t){//层序遍历
    for(int i=0;i<MAX_SIZE;++i){
        cout<<t[i];
    }
    return;
}
char Get_left_child(char *t,char posi){//获取某个结点的左孩子结点
    int i=0;
    for(;i<MAX_SIZE;++i){
        if(t[i]==posi){
            break;
        }
    }
    if(2*i+1<MAX_SIZE){
        return t[2*i+1];
    }
    else{
        return '\0';
    }
}
char Get_right_child(char *t,char posi){//获取某个结点的右孩子结点
    int i=0;
    for(;i<MAX_SIZE;++i){
        if(t[i]==posi){
            break;
        }
    }
    if(2*(i+1)<MAX_SIZE){
        return t[2*(i+1)];
    }
    else{
        return '\0';
    }
}
char Get_root(char *t,char posi){//获取某个结点的根结点
    int i=0;
    for(;i<MAX_SIZE;++i){
        if(t[i]==posi){
            break;
        }
    }
    int root=i%2==1?(i-1)/2:(i-2)/2;
    if(root<=0){
        return t[0];
    }
    else{
        return t[root];
    }
}
char Get_left_brother(char *t,char posi){//获取某个结点的左兄弟结点
    return Get_left_child(t,Get_root(t,posi));
}
char Get_right_brother(char *t,char posi){//获取某个结点的右兄弟结点
    return Get_right_child(t,Get_root(t,posi));
}
int main(){
    srand(time(NULL));
    char tree[MAX_SIZE];
    Init_tree(tree);
    Create_tree(tree);
    IsEmpty_tree(tree)?cout<<"Empty"<<endl:cout<<"Not_empty"<<endl;
    cout<<"Depth: "<<Depth_tree(tree)<<endl;
    cout<<"Preorder_traversal: ";
    Preorder_traversal(tree,0);
    cout<<endl;
    cout<<"Inorder_traversal: ";
    Inorder_traversal(tree,0);
    cout<<endl;
    cout<<"Postorder_traversal: ";
    Postorder_traversal(tree,0);
    cout<<endl;
    cout<<"Levelorder_traversal: ";
    Levelorder_traversal(tree);
    cout<<endl;
    char temp=tree[rand()%Length_tree(tree)];
    while(temp=='\0'){
        temp=tree[rand()%Length_tree(tree)];
    }
    cout<<"Current_node: "<<temp<<endl;
    cout<<"Left_child: ";
    Get_left_child(tree,temp)=='\0'?cout<<"NULL!"<<endl:cout<<Get_left_child(tree,temp)<<endl;
    cout<<"Right_child: ";
    Get_right_child(tree,temp)=='\0'?cout<<"NULL!"<<endl:cout<<Get_right_child(tree,temp)<<endl;
    cout<<"Root_node: "<<Get_root(tree,temp)<<endl;
    cout<<"Left_brother: ";
    Get_left_brother(tree,temp)==temp?cout<<"NULL!"<<endl:cout<<Get_left_brother(tree,temp)<<endl;
    cout<<"Right_brother: ";
    Get_right_brother(tree,temp)==temp?cout<<"NULL!"<<endl:cout<<Get_right_brother(tree,temp)<<endl;
    return 0;
}
```

***Sample***

```
12345    67
```

***Out***

```
Not_empty
Depth: 4
Preorder_traversal: 1245673
Inorder_traversal: 4265713
Postorder_traversal: 4675231
Levelorder_traversal: 1234567
Current_node: 5
Left_child: 6
Right_child: 7
Root_node: 2
Left_brother: 4
Right_brother: NULL!
```